package it.defendimattia.backenddemo.service;

import java.math.BigDecimal;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.web.server.ResponseStatusException;

import it.defendimattia.backenddemo.model.Watch;
import it.defendimattia.backenddemo.repository.WatchRepository;
import it.defendimattia.backenddemo.specification.WatchSpecification;

/**
 * Service layer for managing luxury watches.
 * 
 * <p>
 * Provides operations for CRUD (Create, Read, Update, Delete) and search
 * functionality.
 * Handles business logic and validation related to watches.
 * </p>
 */
@Service
public class WatchService {

    @Autowired
    private WatchRepository watchRepo;

    /**
     * Retrieves all watches.
     * 
     * @return a list of all {@link Watch} entities
     */
    public List<Watch> getAllWatches() {
        return watchRepo.findAll();
    }

    /**
     * Retrieves a single watch by its unique identifier (ID).
     * 
     * @param id the indentifier of the watch
     * @return the {@link Watch} with the given id
     * @throws ResponseStatusException if no watch with the given id exists (HTTP
     *                                 404)
     */
    public Watch getWatchById(Integer id) {
        return watchRepo.findById(id)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Watch not found with id " + id));
    }

    /**
     * Searches for watches matching the provided criteria.
     *
     * <p>
     * Each parameter is optional; null values are ignored in the search.
     * </p>
     *
     * @param brand           the brand name to search for
     * @param model           the model name to search for
     * @param caseMaterial    the case material
     * @param strapMaterial   the strap material
     * @param movementType    the type of movement
     * @param waterResistance minimum water resistance in meters
     * @param caseDiameter    case diameter in millimeters
     * @param caseThickness   case thickness in millimeters
     * @param bandWidth       band width in millimeters
     * @param dialColor       dial color
     * @param crystalMaterial crystal material
     * @param complications   complications of the watch
     * @param powerReserve    minimum power reserve in hours
     * @param maxPrice        maximum price in USD
     * @return a list of {@link Watch} entities matching the criteria
     */
    public List<Watch> search(String brand,
            String model,
            String caseMaterial,
            String strapMaterial,
            String movementType,
            Short waterResistance,
            BigDecimal caseDiameter,
            BigDecimal caseThickness,
            BigDecimal bandWidth,
            String dialColor,
            String crystalMaterial,
            String complications,
            Short powerReserve,
            Integer maxPrice) {

        Specification<Watch> spec = Specification.where(WatchSpecification.brandContains(brand))
                .and(WatchSpecification.modelContains(model))
                .and(WatchSpecification.caseMaterialContains(caseMaterial))
                .and(WatchSpecification.strapMaterialContains(strapMaterial))
                .and(WatchSpecification.movementTypeContains(movementType))
                .and(WatchSpecification.waterResistanceGreaterThanEqual(waterResistance))
                .and(WatchSpecification.caseDiameterGreaterThanEqual(caseDiameter))
                .and(WatchSpecification
                        .caseDiameterLessThan(caseDiameter == null ? null : caseDiameter.add(BigDecimal.ONE)))
                .and(WatchSpecification.caseThicknessGreaterThanEqual(caseThickness))
                .and(WatchSpecification.caseThicknessLessThanEqual(caseThickness))
                .and(WatchSpecification.bandWidthGreaterThanEqual(bandWidth))
                .and(WatchSpecification.bandWidthLessThanEqual(bandWidth))
                .and(WatchSpecification.dialColorContains(dialColor))
                .and(WatchSpecification.crystalMaterialContains(crystalMaterial))
                .and(WatchSpecification.complicationsContains(complications))
                .and(WatchSpecification.powerReserveGreaterThanEqual(powerReserve))
                .and(WatchSpecification.priceLessThanEqual(maxPrice));

        return watchRepo.findAll(spec);
    }

    /**
     * Adds a new watch to the repository.
     *
     * @param watch the {@link Watch} to add
     * @return the saved {@link Watch} entity
     * @throws ResponseStatusException if a watch with the same id already exists
     *                                 (HTTP 409)
     */
    public Watch addWatch(Watch watch) {

        if (watch.getId() != null && watchRepo.existsById(watch.getId())) {
            throw new ResponseStatusException(HttpStatus.CONFLICT,
                    "Watch with id " + watch.getId() + " already exists");
        }

        return watchRepo.save(watch);
    }

    /**
     * Updates an existing watch. Only non-null fields in the given {@link Watch}
     * will be updated.
     *
     * @param watch the watch with updated data
     * @return the updated {@link Watch} entity
     * @throws ResponseStatusException if the watch ID is null (HTTP 400)
     *                                 or if the watch does not exist (HTTP 404)
     */
    public Watch updateWatch(Watch watch) {

        if (watch.getId() == null) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "ID is required to update a watch");
        }

        Watch existing = watchRepo.findById(watch.getId())
                .orElseThrow(() -> new ResponseStatusException(
                        HttpStatus.NOT_FOUND, "Watch not found with id " + watch.getId()));

        if (watch.getBrand() != null)
            existing.setBrand(watch.getBrand());
        if (watch.getModel() != null)
            existing.setModel(watch.getModel());
        if (watch.getCaseMaterial() != null)
            existing.setCaseMaterial(watch.getCaseMaterial());
        if (watch.getStrapMaterial() != null)
            existing.setStrapMaterial(watch.getStrapMaterial());
        if (watch.getMovementType() != null)
            existing.setMovementType(watch.getMovementType());
        if (watch.getWaterResistance() != null)
            existing.setWaterResistance(watch.getWaterResistance());
        if (watch.getCaseDiameter() != null)
            existing.setCaseDiameter(watch.getCaseDiameter());
        if (watch.getCaseThickness() != null)
            existing.setCaseThickness(watch.getCaseThickness());
        if (watch.getBandWidth() != null)
            existing.setBandWidth(watch.getBandWidth());
        if (watch.getDialColor() != null)
            existing.setDialColor(watch.getDialColor());
        if (watch.getCrystalMaterial() != null)
            existing.setCrystalMaterial(watch.getCrystalMaterial());
        if (watch.getComplications() != null)
            existing.setComplications(watch.getComplications());
        if (watch.getPowerReserve() != null)
            existing.setPowerReserve(watch.getPowerReserve());
        if (watch.getPrice() != null)
            existing.setPrice(watch.getPrice());

        return watchRepo.save(existing);
    }

    /**
     * Deletes a watch by its ID.
     *
     * @param id the identifier of the watch to delete
     * @throws ResponseStatusException if no watch with the given id exists (HTTP
     *                                 404)
     */
    public void deleteWatch(Integer id) {

        Watch existing = watchRepo.findById(id)
                .orElseThrow(() -> new ResponseStatusException(
                        HttpStatus.NOT_FOUND, "Watch not found with id " + id));

        watchRepo.delete(existing);
    }

}
